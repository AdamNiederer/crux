== Graph Query

=== Basic Graph Queries

Crux needs to resolve and join entities as of a certain point in
bitemporal time efficiently. This is the main feature of Crux. Secondary
to this is support for normal filter and range queries on the found
entities.

Initially, Crux assumes to have all indexes needed to respond to a query
on a query node. Data might potentially be sharded in various ways, so
different query nodes see different data, or collaborate to resolve the
full query, but this is beyond the scope of the first MVP.

As the design of Crux currently assumes a transaction log feeding into
the indexes, getting the latest view of the world, and reading your own
writes requires some form of blocking to ensure the data you wrote
actually has reached the index. One approach is to simply provide an API
with timeout, waiting for a point of time to reach the query node before
executing the query.

* https://www.w3.org/wiki/DataSetRDFDumps[Linked Data Sets]
* https://snap.stanford.edu/index.html[Stanford Network Analysis
Project]
* https://github.com/Datomic/mbrainz-sample[Datomic MusicBrainz sample
database]
* https://blog.dgraph.io/post/benchmark-neo4j/[Neo4j vs Dgraph - The
numbers speak for themselves]
* https://www.arangodb.com/2018/02/nosql-performance-benchmark-2018-mongodb-postgresql-orientdb-neo4j-arangodb/[NoSQL
Performance Benchmark 2018 – MongoDB, PostgreSQL, OrientDB, Neo4j and
ArangoDB]
* http://tinkerpop.apache.org/docs/current/dev/provider/[TinkerPop
Provider Docimentation]
* https://github.com/datablend/fluxgraph[Fluxgraph (tinkerpop 2 on
Datomic)]
* https://event.cwi.nl/grades/2017/12-Apaci.pdf[Do We Need Specialized
Graph Databases? Benchmarking Real-Time Social Networking Applications]
* http://www.ldbcouncil.org/[LDBC: The graph & RDF benchmark reference]
* http://www.cs.ox.ac.uk/isg/tools/RDFox/2014/AAAI/[RDFox Tests]
* http://swat.cse.lehigh.edu/pubs/guo05a.pdf[LUBM: A Benchmark for OWL
Knowledge Base Systems]
* http://swat.cse.lehigh.edu/projects/lubm/[LUBM]

=== Indexes

The main complication in Crux is link:bitemp.md[bitemporality]. The
as-of view should be resolved for both business and transaction time,
both defaulting to now, without the user having to deal with these
temporal aspects in the query or schema. This is one of Crux main
differentiating features.

One option is to store indexes similar to how it’s done in this article:
https://www.cockroachlabs.com/blog/sql-in-cockroachdb-mapping-table-data-to-key-value-storage/[SQL
in CockroachDB: Mapping Table Data to Key-Value Storage]

Time could be represented as two additional longs, one for business and
one for transaction time, at the end of the key. It’s likely faster if
this time is ``reversed'', so later dates come first in the index.
Another alternative is an
https://redis.io/topics/indexes#multi-dimensional-indexes[multi
dimensional index]. There are many variants on this, like
https://en.wikipedia.org/wiki/R-tree[R-trees], but most of them are
costly to build.

We want the indexes both to be fast, and also decoupled from a single
immutable time-line. Especially, corrections of the past should not cost
more than any other indexing. Deletions at any point should also be
simple. Indexes should be possible to backup and resume from the log, so
the entire index doesn’t need to be rebuilt from scratch in case of
query node failure.

The strategy of building indexes and what’s stored in them should be
decoupled from the way the indexes actually are built and stored. That
is, it should be simple to swap out the underlying store or stores. This
doesn’t mean this necessarily should be simple to do while running,
which would be a post MVP feature.

* https://redis.io/topics/indexes[Secondary indexing with Redis]
* https://arxiv.org/abs/1210.0481[Leapfrog Triejoin: a worst-case optimal join algorithm]
* https://developer.logicblox.com/wp-content/uploads/2013/10/LB1201_LeapfrogTriejoin.pdf[LogicBlox Technical Report: Leapfrog Triejoin: A Worst-Case Optimal Join Algorithm]
* https://www.cockroachlabs.com/blog/better-sql-joins-in-cockroachdb/[On the Way to Better SQL Joins in CockroachDB]
* https://arxiv.org/abs/1604.03234[Hippo: A Fast, yet Scalable, Database Indexing Approach]
* https://arxiv.org/abs/1801.10207[A-Tree: A Bounded Approximate Index Structure]
* https://en.wikipedia.org/wiki/Spatial_index[Spatial index]
* https://docs.dgraph.io/design-concepts/[Dgraph Design Concepts]
* https://people.eecs.berkeley.edu/~anuragk/papers/zipg.pdf[ZipG: A Memory-efficient Graph Store for Interactive Queries]
* https://people.eecs.berkeley.edu/~anuragk/succinct-techreport.pdf[Succinct: Enabling Queries on Compressed Data]
* https://www.usenix.org/system/files/conference/atc13/atc13-bronson.pdf[TAO: Facebook’s Distributed Data Store for the Social Graph]
* https://www.slideshare.net/thobe/an-overview-of-neo4j-internals[An overview of Neo4j Internals]
* https://www.arangodb.com/2016/04/index-free-adjacency-hybrid-indexes-graph-databases/[Index Free Adjacency or Hybrid Indexes for Graph Databases]
* https://www.datastax.com/2016/08/inside-dse-graph-what-powers-the-best-enterprise-graph-database[Inside DSE Graph: What Powers the Best Enterprise Graph DB]
* https://www.researchgate.net/publication/221465140_Adaptive_Tuple_Differential_Coding[Adaptive Tuple Differential Coding]
* https://github.com/ndimiduk/orderly[Orderly: Schema and type system for creating sortable byte]
* https://arxiv.org/abs/1307.4635[Integrating Datalog and Constraint Solving]
* https://people.csail.mit.edu/mcarbin/papers/aplas05.pdf[Using Datalog with Binary Decision Diagrams for Program Analysis]
* https://www.informatik.uni-kiel.de/~mh/lehre/abschlussarbeiten/msc/christiansen.pdf[A purely functional implementation of ROBDDs in Haskell]
* http://discovery.ucl.ac.uk/1474713/1/main.pdf[On Fast Large-Scale Program Analysis in Datalog]
* https://pdfs.semanticscholar.org/004c/2bd66cc6e8aeb9f03c0ea88041d05981acb6.pdf[Efficient Lazy Evaluation of Rule-Based Programs]
* http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.5371&rep=rep1&type=pdf[The LEAPS Algorithms]
* https://web.archive.org/web/20120308104055/http://ssdi.di.fct.unl.pt/krr/docs/magicsets.pdf[Magic sets and other strange ways to implement logic programs]
* https://pdfs.semanticscholar.org/9374/f0da312f3ba77fa840071d68935a28cba364.pdf[What You Always Wanted to Know About Datalog (And Never Dared to Ask)]
* http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.1950&rep=rep1&type=pdf[Magic functions: A technique to optimize extended datalog recursive  programs]
* https://arxiv.org/abs/1806.01799[Survey and Taxonomy of Lossless Graph Compression and Space-Efficient Graph Representations]
* https://github.com/diegocaro/temporalgraphs/blob/master/docs/index.md[Compact Data Structures and Query Processing for Temporal Graphs]
* http://www.vldb.org/pvldb/vol6/p517-yuan.pdf[TripleBit: a Fast and Compact System for Large Scale RDF Data]
* http://webdam.inria.fr/Alice/[Foundations of Databases]
* https://github.com/frankmcsherry/blog/blob/master/posts/2018-05-19.md[A relatively simple Datalog engine in Rust]
* https://github.com/frankmcsherry/blog/blob/master/posts/2016-06-21.md[Differential datalog]
* http://www.frankmcsherry.org/dataflow/relational/join/2015/04/11/genericjoin.html[Worst-case optimal joins, in dataflow]
* https://github.com/comnik/clj-3df[Clojure(Script) client for Declarative Differential Dataflows]
* http://tonsky.me/blog/datascript-internals/[A shallow dive into DataScript internals]
* https://arxiv.org/abs/1302.0914[Beyond Worst-Case Analysis for Joins with Minesweeper]
* https://arxiv.org/abs/1404.0703[Joins via Geometric Resolutions: Worst-case and Beyond]
* https://arxiv.org/abs/1701.07473[Implementation of Tetris as a Model Counter]
* https://arxiv.org/abs/1310.3314[Skew Strikes Back: New Developments in the Theory of Join Algorithms]
* https://arxiv.org/abs/1203.1952[Worst-case Optimal Join Algorithms]
* https://arxiv.org/abs/1707.02769[Compressed Representation of Dynamic Binary Relations with Applications]
* https://arxiv.org/abs/1707.02759[A succinct data structure for self-indexing ternary relations]
* http://repositorio.uchile.cl/bitstream/handle/2250/126520/Compact%20representation%20of%20Webgraphs%20with%20extended%20functionality.pdf?sequence=1q[Compact representation of Web graphs with extended functionality]
* https://www.cs.cmu.edu/~pavlo/papers/mod601-zhangA-hm.pdf[SuRF: Practical Range Query Filtering with Fast Succinct Tries]
* https://arxiv.org/abs/1503.02368[EmptyHeaded: A Relational Engine for Graph Processing]
* http://www.gecode.org/papers/Tack_PhD_2009.pdf[Constraint Propagation - Models, Techniques, Implementation]
* https://oss.redislabs.com/redisgraph/design/[RedisGraph: A High Performance In-Memory Graph Database]
* https://www.slideshare.net/RedisLabs/redisconf18-lower-latency-graph-queries-in-cypher-with-redis-graph[RedisConf18 - Lower Latency Graph Queries in Cypher with Redis Graph]
* http://graphblas.org[Graph BLAS Forum]
* https://arxiv.org/abs/1504.01039[Graphs, Matrices, and the GraphBLAS: Seven Good Reasons]
* http://www.vldb.org/pvldb/vol11/p1978-jamour.pdf[A Demonstration of MAGiQ: Matrix Algebra Approach for Solving RDF Graph Queries]
* https://people.csail.mit.edu/jshun/6886-s18/[MIT 6.886 Graph Analytics Spring 2018]
* https://spcl.inf.ethz.ch/Research/Performance/LogGraph/loggraph_full.pdf[Log(Graph): A Near-Optimal High-Performance Graph Representation]
* http://www.cs.ucsb.edu/~ravenben/temp/rigel.pdf[Fast and Scalable Analysis of Massive Social Graphs]

=== Retention

The indexes need to respect the link:retention.md[retention] rules setup
for the data itself. As the indexes will contain the decrypted values of
all indexed values, being easily able to derive where a value came from
and if this now needs to be dropped must be possible.

It should further be possible to compact the indexes and support rolling
time windows. Different points in time might have different fidelity in
the index, for example keeping all of the recent data while rolling up
data on a hourly or daily basis further back in time. This can be done
both to save space and for performance reasons by keeping the indexes
smaller and mainly contain data that is likely to be queried. See also
link:schema.md[schema].

Different query nodes could have different retention strategies.

=== Query Language

*Crux ability to query the graph is separate from the syntax of doing
so.*

The important thing is finding and defining the interface between the
indexes and the query front end. Crux might support several query
languages as well as API level index and query engine access. As Crux
will be open source, it should be easy to reuse and understand how the
initial reference implementation provided by JUXT actually works, and
extending or deviate from it at each level.

We could use an EDN-based dialect of Datalog. There is the consideration
of made the queries clause order sensitive. This has some benefits, as
it’s easier to reason about and doesn’t require an advanced query
planner, but also drawbacks, as it makes the query language less
declarative, requiring understanding of index-internals to tweak
queries.

https://en.wikipedia.org/wiki/Datalog[Datalog] is a subset of Prolog,
and we could stay closer to that. Other alternatives are
https://en.wikipedia.org/wiki/Cypher_Query_Language[Cypher],
https://en.wikipedia.org/wiki/Gremlin_(programming_language)[Gremlin]
and https://en.wikipedia.org/wiki/SPARQL[SPARQL].

*Note: unlike these languages, GraphQL isn’t an actual query language.
GraphQL requires extensions to do ad-hoc queries.*

* https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.html[Dedalus:
Datalog in Time and Space]
* https://jena.apache.org/documentation/notes/sse.html[SPARQL
S-Expressions]
* https://github.com/LITMUS-Benchmark-Suite/sparql-to-gremlin[Gremlinator:
An effort towards converting SPARQL queries to Gremlin Graph Pattern
Matching Traversals]
* https://github.com/neo4j-graphql/neo4j-graphql-js[neo4j-graphql-js
(GraphQL to Cypher query execution layer)]
* https://github.com/clojurewerkz/ogre[Ogre is a Clojure Gremlin
Language Variant]
* http://www.vldb.org/pvldb/vol11/p420-sahu.pdf[The Ubiquity of Large
Graphs and Surprising Challenges of Graph Processing]
* https://www.utdallas.edu/~bxt043000/Publications/Technical-Reports/UTDCS-22-11.pdf[RETRO:
A Framework for Semantics Preserving SQL-to-SPARQL Translation]
* https://github.com/twilmes/sql-gremlin[sql-gremlin: Provides a SQL
interface to your TinkerPop enabled graph db]
* https://www.stardog.com/docs/#_graphql_queries[Stardog 5: GraphQL
Queries]
* https://github.com/semantic-integration/hypergraphql[hypergraphql:
GraphQL interface for querying and serving linked data on the Web]
* https://medium.com/@sklarman/querying-linked-data-with-graphql-959e28aa8013[Querying
DBpedia with GraphQL]
* https://calcite.apache.org/[Apache Calcite: The foundation for your
next high-performance database]
