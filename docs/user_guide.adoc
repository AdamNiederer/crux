= User Guide

== Hello World

This guide contains for steps for a simple Hello World with Crux.

==== Start a REPL

Clone the https://github.com/juxt/crux[repo] and fire up a REPL in the
project.

==== Do the necessary requires:

[source,clj]
----
include::../dev/examples.clj[tags=require]
----

==== Start the standalone system:

[source,clj]
----
include::../dev/examples.clj[tags=start-system]
----

For the purposes of this Hello World, we are using the simplest
configuration of Crux, where all the pluggable components are
in-memory constituents. There is no Kafka or RocksDB to worry about.

==== Write a transaction:

[source,clj]
----
include::../dev/examples.clj[tags=submit-tx]
----

==== Make a query:

[source,clj]
----
include::../dev/examples.clj[tags=query]
----

You should get:

[source,clj]
----
include::../dev/examples.clj[tags=should-get]
----

== Project Dependency

As Crux is in development, the best route is to clone the
https://github.com/juxt/crux[GitHub repo]. Once in the repo, run

----
lein install
----

== Embedded Mode.

We can Crux entirely in 'embedded' mode. This means that we will run
components such as Kafka and RocksDB in process, with data stored on
disk.

Add these dependencies to your project, for example in `deps.edn`.

[source,clj,subs="normal"]
----
juxt/crux {:mvn/version "0.1.0-SNAPSHOT"}

org.apache.kafka/kafka_2.11 {:mvn/version "2.1.0"}
org.rocksdb/rocksdbjni {:mvn/version "5.17.2"} <1>
----
<1> We are using RocksDB for the purposes of getting you up and
running. To switch out to another KV store, see TODO.

=== Start Crux

First we define the following configuration:

[source,clj]
----
include::../dev/dev.clj[tags=dev-options]
----

This is sample code to start Crux, found in `dev/dev.clj`.

[source,clj]
----
include::../dev/dev.clj[tags=dev-system]
----
<1> The Crux components being started all implement `java.io.Closeable`. The code above contains rudimentrary setup for managing life-cycled components - it should be straightforward to make use of a library such as https://github.com/stuartsierra/component[Component] or https://github.com/weavejester/integrant[Integrant].
<2> You could modify this, if you want to run Kafka outside the local process.

== Query

Crux query capability is easiest summarized via an example:

[source,clj]
----
(q/q db
    '{:find  [?e2]
      :where [(follow ?e1 ?e2)]
      :args [{:?e1 :1}]
      :rules [[(follow ?e1 ?e2)
              [?e1 :follow ?e2]]
             [(follow ?e1 ?e2)
              [?e1 :follow ?t]
              (follow ?t ?e2)]]})
----

The `db` is retrieved via a call to `crux.query/db` which optionally
takes business and transaction time. The call will block until the local
index has seen the transaction time, if provided. The `crux.query/q`
takes 2 or 3 arguments, `db` and `q` but also optionally a `snapshot`
which is already opened and managed by the caller (using `with-open` for
example). This version of the call returns a lazy sequence of the
results, while the other verision provides a set. A snapshot can be
retreived from a `kv` instance via `crux.kv-store/new-snapshot`.

The `:args` key contains a relation where each map is expected to have
the same keys. These keys are turned into logic variable symbols and the
relation is joined with the rest of the query. The elements must
implement `Comparable`.

Crux does not support variables in the attribute position. The entity
position is hard coded to mean the `:crux.db/id` field.

== Transactions

The four transaction (write) operations are as follows:

[source,clojure]
----
[:crux.tx/put :http://dbpedia.org/resource/Pablo_Picasso
"090622a35d4b579d2fcfebf823821298711d3867"
#inst "2018-05-18T09:20:27.966-00:00"]

[:crux.tx/cas :http://dbpedia.org/resource/Pablo_Picasso
"090622a35d4b579d2fcfebf823821298711d3867"
"048ebba27e1da223ce97dded59d46e069ddf921b"
#inst "2018-05-18T09:21:31.846-00:00"]

[:crux.tx/delete :http://dbpedia.org/resource/Pablo_Picasso
#inst "2018-05-18T09:21:52.151-00:00"]

[:crux.tx/evict :http://dbpedia.org/resource/Pablo_Picasso
#inst "2018-05-18T09:21:52.151-00:00"]
----

The business time is optional and defaults to transaction time, which is
taken from the Kafka log. Crux currently writes into the past at a
single point, so to overwrite several versions or a range in time, one
is required to submit a transaction containing several operations.
Eviction works a bit differently, and all versions at or before the
provided business time are evicted.

The hashes are the SHA-1 content hash of the documents. Crux uses an
attribute `:crux.db/id` on the documents that has to line up with the id
it is submitted under.

A document looks like this:

[source,clj]
----
{:crux.db/id :http://dbpedia.org/resource/Pablo_Picasso
 :name "Pablo"
 :last-name "Picasso"}
----

In practice when using Crux, one calls `crux.db/submit-tx` with a set of
transaction operations as above, where the hashes are replaced with
actual documents:

[source,clj]
----
[[:crux.tx/put :http://dbpedia.org/resource/Pablo_Picasso
 {:crux.db/id :http://dbpedia.org/resource/Pablo_Picasso
  :name "Pablo"
  :last-name "Picasso"}
 #inst "2018-05-18T09:20:27.966-00:00"]]
----

For each operation the id and the document are hashed, and this version
is submitted to the `tx-topic` in Kafka. The document itself is
submitted to the `doc-topic`, using its content hash as key. This latter
topic is compacted, which enables later deletion of documents.

If the transaction contains CAS operations, all CAS operations must pass
their pre-condition check or the entire transaction is aborted. This
happens at the query node during indexing, and not when submitting the
transaction.

== Configuration

=== K/V Store

Supported KV stores are RocksDB, LMDB and an in-memory store.
