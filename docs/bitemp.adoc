= Bitemporality

[#bitemp-why]
== Why?

The rationale for bitemporality is also explained in this https://juxt.pro/blog/posts/value-of-bitemporality.html[blog post].

A baseline notion of time that is always available is
`transaction-time`; the point at which data is transacted into the
database.

Bitemporality is the addition of another time-axis: `valid-time`.

.Time Axes
[#table-conversion%header,cols="d,d"]
|===
|Time|Purpose
|`transaction-time`|Used for audit purposes, technical requirements such as event sourcing.
|`valid-time`|Used for querying data across time, historical analysis.
|===

`transaction-time` represents the point at which data arrives into the
database. This gives us an audit trail and we can see what the state
of the database was at a particular point in time. You cannot write a
new transaction with a `transaction-time` that is in the past.

*valid-time* is an arbitrary time that can originate from an upstream
 system, or by default is set to transaction-time. Valid time is
 what users will typically use for query purposes.

****
Writes can be made in the past of valid-time. Users will normally
ask _"what is the value of this entity at valid-time?"_ regardless if
this history has been rewritten several times at multiple
transaction-times.

Only if you want to ensure consistent reads across nodes or to query
for audit reasons, would you want to consider using both
transaction-time and valid-time.
****

NOTE: In Crux, when `transaction-time` isn't specified, it is set to
_now_. When writing data, in case there isnâ€™t any specific valid-time
available, valid-time and transaction-time take the same value.

== Valid Time

In any situation where your database isn't the ultimate owner of the
data and where corrections to data can flow in from various sources,
and at various times, then *transaction-time* isn't always suitable
for historical queries.

Imagine you have a financial trading system and you want to perform
calculations based on the official 'end of day', that occurs each day
at 17:00 hours. Does all the data arrive into your database at exactly
17:00? Or does the data arrive in fact arrive from an upstream source,
and we have to allow for some data to arrive out of order, and some
might just arrive after 17:00?

This can often be the case with high throughput systems where there
are clusters of processing nodes, enriching the data before it gets to
our store.

In this example, we want our queries to include the straggling bits of
data for our calculation purposes, and this is where *valid-time*
comes in. When data arrives into our database, it can come with an
arbitrary time-stamp that we can use for querying purposes.

We can tolerate data arriving out of order, as we're not completely
dependent on transaction-time.
1
****
In a ecosystem of many systems, where one cannot control
the ultimate time line, or other systems abilities to write into the
past, one needs bitemporality to ensure evolving but consistent views
of the data.
****

== Transaction Time

For audit reasons, we might wish to know with certainty the value of a
given entity-attribute at a given `tx-instant`. In this case, we want to
exclude the possibility of the valid past being amended, so we need a
pre-correction view of the data, relying on `tx-instant`.

To achieve this you can use `as-of` using `ts` (`valid-time`) and `tx-ts`
(`transaction-time`).

****
Only if you want to ensure consistent reads across nodes or to query
for audit reasons, would you want to consider using both
transaction-time and valid-time.
****

== References

* https://juxt.pro/blog/posts/value-of-bitemporality.html
* https://en.wikipedia.org/wiki/Temporal_database[Temporal database]
* https://martinfowler.com/eaaDev/timeNarrative.html[Temporal Patterns]
* https://kx.com/blog/kx-insights-powering-business-decisions-bitemporal-data/[Kx Insights: Powering Business Decisions with Bitemporal Data]
